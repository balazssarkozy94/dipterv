%----------------------------------------------------------------------------
\chapter{Szoftveres komponensek}
%----------------------------------------------------------------------------
\lstset{language=C, style=customc}

%----------------------------------------------------------------------------
\section{Mikrokontroller}
%----------------------------------------------------------------------------

A C-RTU kiegészítõ moduljaiban leggyakrabban az STM32F303 mikrokontrollert használjuk, mivel ez a processzor már kellõen erõs az összes eddig felmerült feladat ellátására, ezek mellett viszont nagyobb darabszámnál viszonylag alacsony költségû.

A maximális órajel 72MHz, ehhez 90 DMIPS számítási teljesítmény társul. Tartalmaz ezek mellett FPU-t, ami az analóg alkalmazások esetén rendkívül hasznos. Perifériák tekintetében is jól felszerelt a kontroller, rengeteg timer, ADC csatorna és kommunikációs interfész áll a fejlesztõ rendelkezésére.

%----------------------------------------------------------------------------
\section{Emulált EEPROM}
%----------------------------------------------------------------------------

Számos beágyazott rendszerben van szükség nem felejtõ memória használatára, a CR-PM3 esetében például a kalibrációs adatokat mindenképpen el kell tárolni, ezek pedig legyártott készülékenként változni fognak, amely az alkatrészek szórásából következik. Ezek a nem felejtõ memóriák leggyakrabban külsõ flash, vagy EEPROM típusúak, újabban pedig már az MRAM magnetorezisztív adattárolók szerepe is növekszik. Ezek a nem felejtõ memóriák viszonylag alacsony plusz költséget jelentenek, a hely igényük a nyomtatott áramkörön 1cm\textsuperscript{2} alatti, ez pedig a legtöbb alkalmazásban nem jelent szûk keresztmetszetet.

Mindezek ellenére, érdemes gondolni arra, hogy a mai mikrokontrollerek programmemóriája flash, amit menet közben is tudunk page-enként törölni, illetve szavanként írni. Miért kellene külön alkatrészeket beletervezni az áramkörbe, kommunikációs interfészeket használni, ha a beépített flash-ben néhány lap kijelölésével ugyanúgy egy nem felejtõ memóriát tudunk létrehozni?

Az STMicroelectronics által kiadott emulált EEPROM driverek segítségével könnyen megvalósíthatjuk a nemfelejtõ memóriát, a fejlesztõnek mindössze néhány definiált konstans értékét kell megadni, majd néhány függvény használatával egyszerûen írni és olvasni a változókat. Mivel a flash memória egyik sajátossága, hogy már egyszer írt memória területet csak törlés után lehet újra írni, illetve törölni csak egész lapokat lehet, így az emulált EEPROM megvalósításához legalább két lapra van szükség. Az emulált EEPROM-ban 16 bites adatregiszterek vannak, ezekhez pedig 16 bites virtuális címek tartoznak. A driver beírás esetén a lista legvégére írja a virtuális címet és az adatot. A flash memóriában törlés után minden bit 1-es értéket vesz fel, ezt használja ki  az olvasás függvény, ami az emulált EEPROM memória végét a 0xFFFF virtuális címû regiszterrel detektálja. Az olvasás, amennyiben több azonos címet is talál a memóriában, mindig a legutolsó értékét adja vissza, hiszen ezt írtuk be legutoljára. Amennyiben a kijelölt lap betelne, a driver a változók legutolsó értékeit átmenti egy másik lapra, majd törli a betelt lapot. A driver publikus függvényei:

\begin{lstlisting}
uint16_t EE_Init(void);
uint16_t EE_ReadVariable(uint16_t VirtAddress, uint16_t* Data);
uint16_t EE_WriteVariable(uint16_t VirtAddress, uint16_t Data);
\end{lstlisting}
Az \ref{st_emulated_eeprom_compare} táblázatban látható a külsõ EEPROM illetve a flash alapú, emulált EEPROM paramétereinek összehasonlítása.

\begin{table}[!ht]
\centering
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Jellemzõ} & \textbf{Külsõ EEPROM} & \textbf{Emulált EEPROM} \\ \hline
Írási idõ &  20ms  &  244$\mu$s...82ms  \\ \hline
Törlési idõ &  5ms/bájt  & 20...40ms/page \\ \hline
Olvasási idõ &  92$\mu$s  & 10...300$\mu$s\\ \hline
Írási/Törlési ciklus szám &  1 millió  & 10 ezer/page \\ \hline
\end{tabularx}
\caption{EEPROM és emulált EEPROM összehasonlítása 32 bites adatokon}
\label{st_emulated_eeprom_compare}
\end{table}

A CR-PM3-ban a legtöbb kalibrációs változó  típusa egyszeres-precizitású lebegõpontos, ezek letárolása és visszaolvasása 16 bites regiszterekkel némi bit manipulációt igényel, az ezeket megvalósító függvények:

\begin{lstlisting}
void eeStoreFloat(float data, uint16_t ee_address);
void eeReadFloat(volatile float* calib_address, uint16_t ee_address);
\end{lstlisting}

Az emulált EEPROM használata közben rendkívül nagy segítségnek bizonyult az STM32 ST-LINK Utility használata, melyben implementálva van a ''LiveUpdate'' funkció, mellyel futás közben monitorozhatjuk a flash memória tartalmát, ennek egy képernyõképét láthatjuk az \ref{STLINK_LIVE} ábrán. Ezzel a kalibrációs függvények fejlesztése nagyban egyszerûsödött, az esetleges hibákat az elsõ futásnál fel lehetett ismerni. 

\begin{figure}[H]
\centering
\includegraphics[width=120mm, keepaspectratio]{figures/5_1_0_emul_eeprom.PNG}
\caption{STM32 ST-LINK Utility LiveUpdate opcióval}
\label{STLINK_LIVE}
\end{figure}

%----------------------------------------------------------------------------
\section{Firmware}
%----------------------------------------------------------------------------

A beágyazott szoftvert az STM32F303-as kontrollerre KDevelop környezetben írtam, STM32 Standard Peripheral Libraries-t, valamint a Prolan-on belül fejlesztett CR-BASE szoftver réteget használtam. Maga a környezet egy Kubuntu-t futtató virtuális gépen mûködött, melyet a szoftveres kollégák kifejezetten a hardverfejlesztõk igényeinek megfelelõen állítottak össze, ezzel megkímélve a hosszas fejlesztõi környezet konfigurálástól minket. Már az áramkörtervezés folyamatában használtam az STM32CubeMX programot, amellyel egyszerûen felkonfigurálhatjuk a választott STM32-es mikrokontrollert egy grafikus felületen keresztül. 

Mivel a cégen belül Standard Peripheral Libraries-t (SPL) alkalmazunk, a segédprogramot elsõsorban nem kódgenerálásra, hanem a különbözõ perifériák kiosztásának ellenõrzéséhez, az ütközések elkerülésére alkalmaztam. Az SPL az STMicroelectronics által fejlesztett szoftverréteg, amely a fejlesztõ elõl elfedi a regiszterszintû mûveleteket, azonban alacsonyabb szintû mint a szintén gyártó által fejlesztett Hardware Abstraction Layer (HAL), amely például már az interruptokat is elfedi, a fejlesztõnek pedig csak callback függvényeket szolgáltat az interruptból.

%----------------------------------------------------------------------------
\subsection{Program felépítése}
%----------------------------------------------------------------------------

A program reset után, még a hardver inicializáció elõtt a különbözõ mérést leíró struktúrák inicializációjával kezd, az ezekben található pointerek megfelelõ értékének beállításával, és listák feltöltésével. Ezen a ponton kell megadni az eszköznek, hogy pontosan melyik vizsgált paramétereket kívánjuk kiolvasni a DSP-bõl.

	\begin{lstlisting}
  struct meas_register reg_list_L1[MAX_NO_OF_REGS_TO_READ/3];
  struct calib_data calibration_data_l1;
  regs_of_interest_L1.calibration_data = &calibration_data_l1;
  regs_of_interest_L1.no_of_regs = 0;
  regs_of_interest_L1.reg_array = reg_list_L1;
  
  addToRegsOfInterest(&regs_of_interest_L1, "L1 VRMS", AVRMS, 4, _signed, voltage, 50);
  addToRegsOfInterest(&regs_of_interest_L1, "L1 IRMS", AIRMS, 4, _signed, current, 50);
  ...
	\end{lstlisting}

Ezt követõen a flash memóriából, az emulált EEPROM-ból kiolvassa a kalibrációs adatokat, ezeket hozzárendeli a megfelelõ változókhoz.

A C-RTU kötelezõ funkcióinak inicializációja ezután kezdõdik, meghívódik a CR-BASE és C-CAN init függvény, majd a LED-ek, a CAN, a mérési paraméterek, figyelt adatok, verziók beállítása. Ezek helyes lefutása után jönnek a modul specifikus függvényhívások, a különbözõ perifériák, felparaméterezése. A CR-PM3-ban a különbözõ feladatokat a következõ perifériák látják el:

\begin{enumerate}
\item\emph{GPIO} A külvilággal az MCU természetesen a be- és kimeneteit használva kommunikál, ezért ennek a perifériának a használata elengedhetetlen.
\item\emph{Timer} Egy belsõ idõzítõhöz használtam, amellyel rövid, a CR-BASE-ben nem implementált, $\mu$s-es delay függvényt készítettem.
\item\emph{SPI} Az MCU és az ADE7978 közötti kommunikáció kétirányú SPI.
\item\emph{DMA} Az analóg-digitális átalakító kimenetét kezelem DMA-val, így a processzor számára overhead nélkül szolgáltat információt az analóg értékekrõl.
\item\emph{ADC} A buszfeszültséget, 3.3V-os tápfeszültséget és az integrált hõmérõt mérem vele.
\item\emph{NVIC, EXTI} Az external interrupt-ok kezeléséhez szükséges, melyeket az ADE7978 ad ki. 
\item\emph{UART} Hibakeresés során használtam fejlesztéshez egy könnyen kezelhetõ interfészként.
\end{enumerate}

Az inicializációk után még a CR-BASE segítségével létrejön egy-egy 1000, 500 és 100ms-es taszk, amelybe a különbözõ, nem idõkritikus ciklikus feladatok hajthatóak végre.

Ez után bekerül a program futása a main-ben található végtelen ciklusba, amelyben a CR-BASE crBaseHandler() függvényét hívja. Ez kezeli a C-CAN üzenetek interruptos fogadását bufferelve, illetve a CR-BASE összes idõzítéssel kapcsolatos funkcióját, mint például a LED-ek villogtatását, vagy bármilyen elõre regisztrált függvény meghívását.

A modul mûködése során a három regisztrált ciklikus taszk-ban, interruptokban, illetve DMA segítségével történnek a különbözõ funkciók.

\begin{enumerate}
	\item \emph{tickHandler1000():} Elsõsorban debug funkciók megvalósítására volt használva, a különbözõ gyors események láthatóvá tételéhez, lassításához, például, hogy valamilyen hiba bekövetkezte után csak néhány másodperc után kapcsoljon le a hiba LED. 
	\item \emph{tickHandler500():} A jelenlegi prototípuson itt történik a CR-BASE számára az értékek frissítése. Amennyiben a CR-BASE szignifikancia, vagy idõzítési kritériumai alapján szükséges, akkor ezután küldi fel az alapkészüléknek a mért adatokat.
	
	\item \emph{tickHandler100():} Mivel a nullvezetõt figyelõ bemenetre nem használható a nullátmenet interrupt, így az ehhez tartozó értékek frissítése ebben a taszkban történik.
	
\item \emph{EXTI interrupt:} Az ADE7978 három konfigurálható interrupt kimenettel rendelkezik, melyek mindegyike be van kötve az STM32-es kontrollerbe, azonban a jelenlegi alkalmazásban ezek közül csak egy láb van használatba. A DSP egyik maszk regiszterének írásával lehet engedélyezni a különbözõ események hatására az interruptokat, amelyek ugyanazt a lábat húzzák alacsony logikai értékre. Ahhoz, hogy az interrupt forrását eldöntsük, ki kell olvasni a maszk regiszterhez tartozó státusz regisztert, és ott meg kell vizsgálni az interrupt bitek állapotát, majd a megfelelõ érték beírásával törölni a flaget. Késõbbi alkalmazásban elképzelhetõ, hogy több interruptot is használni kell majd, de jelenleg a használt interruptok a következõk: reset utáni belsõ inicializáció kész, illetve a három fázison a feszültség nullátmenet események. Ezeknek a figyelése azért fontos, mert az ADE7978 a legtöbb számolt paramétert hálózati ciklusonként számolja ki, így érdemes ezen eseményekre szinkronizálni, hogy minden eredményt kiolvassunk, de véletlenül se olvassuk ki ugyanazt az értéket többször, majd ezeket átlagolni tudjuk. Egy probléma azonban ezzel a módszerrel, hogy amennyiben például a hálózati feszültség nullátmenet nélkül állna be egy hibás állapotba, a kiolvasott érték nem tükrözné a valóságot. Ezt kiküszöbölni kivétel kezeléssel lehet, az egyik ciklikus taszk felügyeletével. Amennyiben nem érkezik adott idõn belül nullátmenet interrupt, frissítjük a fázishoz tartozó értékeket a DSP megfelelõ azonnali érték regiszterével.

	\item \emph{DMA:} Az ADC által beolvasott négy csatorna: a hátlapi 12V, a 3.3V a VBAT bemeneten keresztül, az integrált hõmérõ, valamint a beépített feszültség referencia. Ennek a négy értéknek a konverziója folyamatosan fut az ADC-ben, és amikor egy konverziós sorozat befejezõdik, akkor elsül egy belsõ jel, aminek a hatására a DMA kiolvassa az eredményt, és áthelyezi egy-egy globális változóba azokat. Ez a teljes folyamat a processzortól független, azt egyáltalán nem terheli. Ugyan az interruptos lekezelése az ADC-nek is megfelelõ lett volna, a számítási teljesítmény elbírná, azonban a fejlesztés szempontjából sokkal kényelmesebb, hiszen a konverzió befejezõdésének interruptjával így nem kell foglalkozni, a program futását az nem akasztja meg, a változók egyszerûen ''maguktól frissülnek''.
	
\end{enumerate}


%----------------------------------------------------------------------------
\subsection{Mérõ IC-t kezelõ függvények, struktúrák}
%----------------------------------------------------------------------------

A firmware készítése során amennyire lehetett, az objektum orientáltságra törekedtem, így a mérési eredmények, kalibrációs adatok és beállítások struktúrákban vannak tárolva. Ahol csak lehetett a hibák elkerülésének érdekében enum típusokat vettem fel. 

\begin{lstlisting}
enum issigned{
    _signed,
    _unsigned
};

enum dimension{
    voltage,
    current,
    power,
    energy,
    temperature,
    scalar
};

struct meas_register{
    const char* tag;
    int64_t value;
    int64_t avg_acc;
    uint32_t avg_cnt;
    uint32_t avg_cycles;
    uint16_t reg_addr;
    uint8_t reg_size;
    enum issigned type;
    enum dimension dimension;
};

struct calib_data{
    float v_lsb;
    float i_lsb;
    float wh_lsb;
    int32_t vgain;
    int32_t igain;
    int32_t phcal;
};
\end{lstlisting}

A meas\_register struktúra írja le az egyes mérendõ változókat, a mérési módjukat:

\begin{enumerate}
	\item \emph{tag:} Egy konstans string, amely az emberi olvasásra alkalmas nevét tartalmazza a regiszternek, így debug célokra kiváló. 
	\item \emph{value:} Az átlagolt értéke a regiszternek.
	\item \emph{avg\_acc:} Az átlagoláshoz szükséges akkumulátor változó.
	\item \emph{avg\_cnt:} Az átlagoláshoz szükséges futó változó.
	\item \emph{avg\_cycles:} Az átlagoláshoz használt minták számát határozza meg.
	\item \emph{reg\_addr:} A regiszter címe az ADE7978-ban.
	\item \emph{reg\_size:} A regiszter mérete bájtokban kifejezve.
	\item \emph{type:} Megmutatja, hogy elõjeles, vagy elõjel nélküli változóként kezeljük a regisztert.
	\item \emph{dimension:} A mérendõ mennyiség dimenzióját adja meg, mely lehet feszültség, áram, teljesítmény, energia, hõmérséklet, vagy pedig skalár.
\end{enumerate}

A calib\_data struktúra tartalmazza az összes, valamilyen kompenzációhoz kapcsolódó értéket. A szeparált tárolás egyszerûvé tette ezeknek az értékeknek a letárolását nemfelejtõ memóriába, majd visszaolvasását, illetve fejlesztés alatt, a kalibráció kifejlesztése elõtt könnyen át lehetett hidalni, így pedig lehetett használni a kompenzálatlan értékeket.

A meas\_register-eket regs\_of\_interest\_type struktúrák foglalják össze fázisonként. Ezekhez hozzá van rendelve továbbá a kalibrációs adatokat tartalmazó calib\_data struktúra egy-egy példánya, valamint egy változó tartalmazza a felvett meas\_register-ek számát.  

\begin{lstlisting}
struct regs_of_interest_type{
   struct meas_register* reg_array;
   struct calib_data* calibration_data;
   uint8_t no_of_regs;
};
\end{lstlisting}

A regs\_of\_interest\_type gyûjtõ objektumok kezelése egy hozzáadó, egy frissítõ, és egy kiolvasó függvénnyel történik.

\begin{lstlisting}
  addToRegsOfInterest(&regs_of_interest_L1, "L1 VRMS", AVRMS, 4, _signed, voltage, 50);
  updateRegsOfInterest(regs_of_interest_L1);
  output_buffer[1] = readRegsOfInterest(regs_of_interest_L1, "L1 VRMS"); 
\end{lstlisting}

%----------------------------------------------------------------------------
\subsection{Debug UART}
%----------------------------------------------------------------------------

A fejlesztés támogatásához a készülékben helyet kapott egy kivezetett UART port. Ennek a kezelése sokkal egyszerûbb, mint a C-CAN használata, így egyszerû diagnosztikához kitûnõen alkalmas. A jobb átláthatóság érdekében a porton nem egyszerûen kiírja az eszköz az adatokat, illetve szöveges üzeneteket, hanem ANSI escape karakterek használatával egy VT100 terminál vezérlést valósít meg, kurzor mozgatásokkal, így hosszabb képernyõ tartalmak esetén sem fog villogni a kép, az elõzõ képernyõ tartalmát egyszerûen felülírja az új. A VT100 terminál kezelése esetén minden vezérlõutasítás elõtt az ''Esc'' ASCII karaktert kell kiküldeni, amelynek értéke 0x1B.

\begin{figure}[!ht]
\centering
\includegraphics[width=60mm, keepaspectratio]{figures/5_1_1_dbg_serial.png}
\caption{Debug soros port kimenete}
\end{figure}

A fejlesztés során többször fordult elõ, hogy valamilyen hibás konfigurálás következtében már az inicializáció során elakadt a program futása, ezek forrását a debug interfész segítségével rendkívül egyszerûen, egy-egy sor vagy változó kiíratásával meg lehetett találni.

%----------------------------------------------------------------------------
\section{CR-WEB}
%----------------------------------------------------------------------------

Az alapkészülékben a csomagok megjelenítését, a paraméterezést viszonylag egyszerûen, egy SQL adatbázis megfelelõ kitöltésével lehet megvalósítani. Ezután egy CR-WEB elnevezésû, HTML alapú felületen követhetjük az adatok, paraméterek aktuális értékét, kiegészítve olyan, fejlesztéshez és hibakereséshez hasznos információkkal, mint például az adat utolsó keletkezési ideje, illetve beérkezési ideje. 

Egy külön fülön a modul állapotát is nyomon követhetjük, valamint kiolvashatjuk a C-CAN-en bekövetkezett hibákat, a kiegészítõ modul slave processzorának utolsó resetelésének okát.

Ezek a funkciók fejlesztéshez, mérésekhez rendkívül kényelmesek, az alapkészülék hálózatra való csatlakoztatásával a tényleges kialakítás helyétõl távol is figyelemmel követhetjük és vizsgálhatjuk a C-RTU alapú rendszereket. 

\begin{figure}[!ht]
\centering
\includegraphics[width=150mm, keepaspectratio]{figures/5_3_1_CRWEB.png}
\caption{CR-WEB fejlesztõi felület}
\end{figure}

Egy adat adatbázisba való felvétele az alábbi néhány SQL mûvelet elvégzésével történik:

\begin{lstlisting}[language = SQL]
insert into CRModuleDatas ( moduleTypeId, dataType,ccanChannel,description,tag, siUnit) VALUES ('CR-PM3','MEASURE',401,'L1 fázis feszültség', 'L1_VRMS', 'V');

insert into CRModuleParams (moduleTypeId, ccanChannel, paramId, paramType, paramValue, description, siUnit) VALUES ('CR-PM3', 299,  3, 'uint32', 500,   'L1 fázis feszültség küdési ciklusidõ (>0 küld)', 'ms');

insert into CRModuleParams (moduleTypeId, ccanChannel, paramId, paramType, paramValue, description, siUnit) VALUES ('CR-PM3', 299,  4, 'float',  0.1, 'L1 fázis feszültség küdés szignifikancia (>0 küld)', '');
\end{lstlisting}

Az elsõ mûvelet magát a mérendõ adat felvételét végzi el típussal, mértékegységgel, leírással, C-CAN csatorna hozzárendeléssel együtt. A második és harmadik SQL utasítás az elõbb felvett adathoz tartozó idõzítési kritérium és szignifikancia felvételét végzi el, szintén a megfelelõ C-CAN csatorna lefoglalásával. Ezt követõen a C-RTU alapkészülék már minden szükséges információval rendelkezik az adatok lekérdezéséhez és folyamatos frissítésére.
%----------------------------------------------------------------------------
\section{Gyártás támogatás}
%----------------------------------------------------------------------------

Egy gyártott terméknek elengedhetetlen a tesztelése mielõtt azt eladásra szánja az elõállító. Ez kis darabszámnál még történhet egyedi mérések alapján, melyet a fejlesztõ, vagy egy technikus végez el minden legyártott darabon, azonban ez nem jó hatásfokú, valamint nagyobb darabszámnál szûk keresztmetszetet jelenthet a termék elõállításában, eladásában. Ezt a tesztet összevonhatjuk a termék kalibrációjával, amely szintén elengedhetetlen egy pontos mérõ gyártásánál, hiszen minden felhasznált alkatrésznek lesz valamilyen szórása ezen eltérések kiküszöböléséhez pedig valamilyen precíziós jelforráshoz kell hasonlítani az elkészült mérõt, majd az eredmény alapján a lehetõ legjobban eliminálni a rendszeres hibákat. A végmérés és kalibráció összevonása után egy egyszerûen végrehajtható leírást kapunk, melyet lépésrõl lépésre követve meggyõzõdhetünk a gyártott termék helyességérõl, valamint kalibráció után garantálhatjuk a specifikált pontosságot. Ezen összevont folyamathoz a legjobb megoldás egy végmérõ- és kalibrálószoftvert készíteni, amellyel egy kezelõ egyszerûen elvégezheti ezeket a feladatokat lépésrõl lépésre.

%----------------------------------------------------------------------------
\subsection{Végmérés és kalibráció}
%----------------------------------------------------------------------------

A végmérés és kalibráció a CR-PM3 esetében gyakorlatilag szétválaszthatatlan, mivel a külvilág felé a kimenetei mindössze az elõlapon található LED-ek, az összes csatlakozón mérõbemenet található, ezeknek pedig elengedhetetlen a kalibrációja, e közben pedig meggyõzõdhetünk a helyes mûködésrõl.

%----------------------------------------------------------------------------
\subsubsection{Mérési környezet}
%----------------------------------------------------------------------------


A kalibrációhoz szükséges precíz jelforrást egy Omicron gyártmányú CMC 356 mûszer biztosította. Ez egy egyszerûen használható PC-s felületet biztosít, de késõbb, amennyiben szükséges, távoli vezérlés is megvalósítható egy automatizált teszthez. A mûszer specifikációja háromfázisú konfigurációban az \ref{OmicronCMC356spec} táblázatban látható.

\begin{table}[!ht]
\centering
\begin{tabularx}{\textwidth}{|X|X|}
\hline
\textbf{Paraméter} & \textbf{Érték}\\ \hline
Feszültségtartomány & 0...300VAC	\\ \hline
Feszültséggenerátor tipikus pontossága & <0.03$\%$ reading + 0.01$\%$ range	\\ \hline
Feszültséggenerátor garantált pontossága & <0.08$\%$ reading + 0.02$\%$ range	\\ \hline
Áramtartomány & 0...64AAC	\\ \hline
Áramgenerátor tipikus pontossága & <0.05$\%$ reading + 0.02$\%$ range	\\ \hline
Áramgenerátor garantált pontossága & <0.15$\%$ reading + 0.05$\%$ range\\ \hline
Generátorok frekvencia pontossága & $\pm$0.5ppm	\\ \hline
Névleges frekvenciatartomány & 10...1000Hz	\\ \hline
Teljes frekvenciatartomány & 10...3000Hz	\\ \hline
\end{tabularx}
\caption{Omicron CMC 356 specifikációja háromfázisú konfigurációban}
\label{OmicronCMC356spec}
\end{table}

A CMC 356 kezelése történhet egy, a gyártó által szolgáltatott, Omicron Harmonics segédprogrammal, vagy pedig vezérelhetõ távolról, szkriptek futtatásával, melyeket a mûszerbe integrált Linux-os számítógép hajt végre a vezérlõ utasítások hatására. Sajnos utóbbi implementálására nem volt idõm, így csak a valamivel lassabb és nehézkesebb megoldást alkalmaztam, és a segédprogramban írtam át egyesével a feszültség és áramértékeket a kalibrációhoz.

%----------------------------------------------------------------------------
\subsubsection{STM32 mikrokontrolleren futó szoftver}
%----------------------------------------------------------------------------

A mikrokontroller indulás után kétféle inicializációból tud választani, az egyik a normál futáshoz tartozik, míg a másik a kalibrációhoz szükséges inicializációkat végzi el. Ennek a választásnak a megvalósítása a prototípuson a címbeállító kapcsoló egyikének állása alapján volt, azonban a végleges termékben valamilyen kevésbé hozzáférhetõ megoldást kell majd alkalmazni, hogy normális mûködés közben semmilyen esetre se lehessen kalibrálást indítani.

A kalibráció különbözõ lépéseit C-CAN üzenetek hatására végzi el a CR-PM3, majd az eredményeket letárolja az emulált EEPROM-ba. Normál futás inicializációjakor az EEPROM-ból olvassa ki, és ellenõrzés után tölti be a kalibrációs értékeket.

A C-CAN üzenetek vizsgálata egy beregisztrált kezelõ függvényben történik, amely egy dedikált C-CAN csatornára érkezõ üzenet esetén hívódik meg:

\begin{lstlisting}
CHANNEL_ERR_e calibrateHandler(uint16_t channel, uint8_t* data, uint16_t length)
{
    switch(channel)
    {
        case 300: //312C
        {
            // BEFORE ENTERING THIS SUPPLY 230V, 8A, cosPhi= 1
            calibrateMeteringIC_VIGainMatching();           
            calibrateMeteringIC_VILSBCalib();
            break;
        }
        case 301: //312D
        {
            // BEFORE ENTERING THIS SUPPLY 23V, 0.4A, cosPhi= 1
            calibrateMeteringIC_VIOSMatching();
            break;
        }
        ...
}
\end{lstlisting}

Az egyes függvényekben a különbözõ hibák, illetve azok kompenzációjának kiszámolása és letárolása történik.

%----------------------------------------------------------------------------
\subsubsection{Alapkészüléken futó szoftver}
%----------------------------------------------------------------------------

\begin{figure}[!ht]
\centering
\includegraphics[width=120mm, keepaspectratio]{figures/5_4_2_kalibracio_1.PNG}
\caption{Végmérõ és kalibráló szoftver fõmenüje}
\label{crtu_calib_main}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=120mm, keepaspectratio]{figures/5_4_3_kalibracio_2.PNG}
\caption{Végmérõ és kalibráló szoftver CR-PM3 specifikus menüje}
\label{crtu_calib_crpm}
\end{figure}

A kontrolleren implementált kalibrációs függvények meghívását kiváltó C-CAN üzeneteket az alapkészülék adja ki. A kalibráció és végmérés elvégzéséhez egy egyszerû program fut Linux alól, amely egy primitív, de jól átlátható felületet biztosít az összes C-RTU modulhoz, amelynek fõmenüje \ref{crtu_calib_main} ábrán látható. Az egyes menüpontok kiválasztása esetén egy bash script hívódik meg, ebben kell implementálni a további almenüket, üzenetküldéseket és minden további számítást, tárolást.

Egy-egy új modul komponenseinek implementálása egyszerû, a már meglévõ részegységek újrafelhasználhatók, mint például a LED-ek, nyomógombok, kapcsolók tesztjei.

A modulhoz tartozó almenüben a végmérés és kalibráció lépéseit egymás után hajthatjuk végre, illetve rögzíthetjük a különbözõ készülék paramétereket, mérési adatokat. A modul specifikus almenünek a felépítése a \ref{crtu_calib_crpm} ábrán látható.

